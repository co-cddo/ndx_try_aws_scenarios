"""
Core data generators for UK council sample data.

All generators are deterministic when provided with a seed value,
enabling reproducible test data generation.
"""

import random
import hashlib
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from .config import (
    UK_FIRST_NAMES,
    UK_SURNAMES,
    STREET_TYPES,
    STREET_NAMES,
    UK_CITIES,
    COUNCIL_SERVICES,
    SAMPLE_DATA_MARKER,
    SAMPLE_DATA_PREFIX
)


class UKNameGenerator:
    """
    Generate realistic UK names with proper distribution.

    Features:
    - Deterministic generation with seed
    - Gender-aware name selection
    - Unique name combinations
    - SAMPLE markers for synthetic data identification
    """

    def __init__(self, seed: Optional[int] = None):
        """Initialize name generator with optional seed."""
        self.seed = seed
        self.random = random.Random(seed)
        self._used_combinations = set()

    def generate_name(self, gender: Optional[str] = None) -> Dict[str, str]:
        """
        Generate a single UK name.

        Args:
            gender: 'male', 'female', or None for random selection

        Returns:
            Dict with firstName, lastName, fullName, gender fields
        """
        if gender is None:
            gender = self.random.choice(['male', 'female'])

        if gender not in ['male', 'female']:
            raise ValueError("Gender must be 'male', 'female', or None")

        # Select name ensuring uniqueness
        max_attempts = 100
        for _ in range(max_attempts):
            first_name = self.random.choice(UK_FIRST_NAMES[gender])
            last_name = self.random.choice(UK_SURNAMES)
            combination = (first_name, last_name)

            if combination not in self._used_combinations:
                self._used_combinations.add(combination)
                break

        full_name = f"{first_name} {last_name}"

        return {
            "firstName": first_name,
            "lastName": last_name,
            "fullName": full_name,
            "gender": gender,
            "sampleMarker": SAMPLE_DATA_MARKER
        }

    def generate_names(self, count: int) -> List[Dict[str, str]]:
        """
        Generate multiple unique UK names.

        Args:
            count: Number of names to generate

        Returns:
            List of name dictionaries
        """
        names = []
        for i in range(count):
            # Alternate gender for balanced distribution
            gender = 'male' if i % 2 == 0 else 'female'
            names.append(self.generate_name(gender))

        return names


class UKAddressGenerator:
    """
    Generate valid UK addresses with proper postcode formats.

    Features:
    - Valid UK postcode patterns (B12 3AB, M1 4BN, LS6 2QR)
    - Realistic street address combinations
    - City and district assignment
    - SAMPLE markers for synthetic data
    """

    def __init__(self, seed: Optional[int] = None):
        """Initialize address generator with optional seed."""
        self.seed = seed
        self.random = random.Random(seed)

    def _generate_postcode(self, prefix: str) -> str:
        """
        Generate a valid UK postcode format.

        Format: PREFIX + DISTRICT (1-2 digits) + SPACE + SECTOR (digit) + UNIT (2 letters)
        Example: B12 3AB, M1 4BN, LS6 2QR
        """
        district = self.random.randint(1, 99)
        sector = self.random.randint(0, 9)
        unit = ''.join(self.random.choices('ABCDEFGHJKLMNOPQRSTUVWXYZ', k=2))

        return f"{prefix}{district} {sector}{unit}"

    def generate_address(self, city_name: Optional[str] = None) -> Dict[str, str]:
        """
        Generate a complete UK address.

        Args:
            city_name: Specific city name or None for random selection

        Returns:
            Dict with address components and full formatted address
        """
        # Select city
        if city_name:
            city = next((c for c in UK_CITIES if c["name"] == city_name), None)
            if not city:
                city = self.random.choice(UK_CITIES)
        else:
            city = self.random.choice(UK_CITIES)

        # Generate address components
        street_number = self.random.randint(1, 999)
        street_name = self.random.choice(STREET_NAMES)
        street_type = self.random.choice(STREET_TYPES)
        district = self.random.choice(city["districts"])
        postcode = self._generate_postcode(city["postcodePrefix"])

        # Build full address
        address_line1 = f"{street_number} {street_name} {street_type}"

        return {
            "addressLine1": address_line1,
            "addressLine2": district,
            "city": city["name"],
            "postcode": postcode,
            "formattedAddress": f"{address_line1}, {district}, {city['name']}, {postcode}",
            "sampleMarker": SAMPLE_DATA_MARKER
        }

    def generate_addresses(self, count: int) -> List[Dict[str, str]]:
        """
        Generate multiple UK addresses.

        Args:
            count: Number of addresses to generate

        Returns:
            List of address dictionaries
        """
        return [self.generate_address() for _ in range(count)]


class CouncilServiceGenerator:
    """
    Generate council service requests across multiple categories.

    Features:
    - 4 service categories (Waste, Highways, Housing, Council Tax)
    - Realistic request types per category
    - Status tracking (new, in_progress, resolved)
    - Priority levels
    - Timestamps
    """

    def __init__(self, seed: Optional[int] = None):
        """Initialize service request generator with optional seed."""
        self.seed = seed
        self.random = random.Random(seed)

    def _generate_reference(self, category_code: str, index: int) -> str:
        """Generate a service request reference number."""
        timestamp = datetime.now().strftime("%Y%m")
        return f"{SAMPLE_DATA_PREFIX} {category_code}-{timestamp}-{index:05d}"

    def _generate_timestamp(self, days_ago: int) -> str:
        """Generate a timestamp within the last N days."""
        date = datetime.now() - timedelta(days=self.random.randint(0, days_ago))
        return date.isoformat()

    def generate_request(
        self,
        category: Optional[str] = None,
        index: int = 0
    ) -> Dict[str, Any]:
        """
        Generate a single service request.

        Args:
            category: Specific category name or None for random
            index: Request index for reference number generation

        Returns:
            Dict with complete service request data
        """
        # Select category
        if category:
            category_data = next(
                (c for c in COUNCIL_SERVICES["categories"] if c["name"] == category),
                None
            )
            if not category_data:
                category_data = self.random.choice(COUNCIL_SERVICES["categories"])
        else:
            category_data = self.random.choice(COUNCIL_SERVICES["categories"])

        # Generate request details
        request_type = self.random.choice(category_data["types"])
        status = self.random.choice(["new", "in_progress", "resolved"])
        priority = self.random.choice(["low", "medium", "high"])

        # Generate category code for reference
        category_code = ''.join([word[0] for word in category_data["name"].split()])

        return {
            "reference": self._generate_reference(category_code.upper(), index),
            "category": category_data["name"],
            "requestType": request_type,
            "status": status,
            "priority": priority,
            "submittedAt": self._generate_timestamp(30),
            "lastUpdated": self._generate_timestamp(7),
            "sampleMarker": SAMPLE_DATA_MARKER
        }

    def generate_requests(
        self,
        count: int,
        category_distribution: Optional[Dict[str, int]] = None
    ) -> List[Dict[str, Any]]:
        """
        Generate multiple service requests.

        Args:
            count: Total number of requests to generate
            category_distribution: Optional dict of category name -> count

        Returns:
            List of service request dictionaries
        """
        requests = []

        if category_distribution:
            # Generate specific distribution
            index = 0
            for category, cat_count in category_distribution.items():
                for _ in range(cat_count):
                    requests.append(self.generate_request(category, index))
                    index += 1
        else:
            # Even distribution across categories
            categories = [c["name"] for c in COUNCIL_SERVICES["categories"]]
            for i in range(count):
                category = categories[i % len(categories)]
                requests.append(self.generate_request(category, i))

        return requests


class CouncilDataGenerator:
    """
    Main orchestrator for comprehensive UK council data generation.

    Combines all generators and provides unified interface for
    scenario-specific data generation.

    Features:
    - Deterministic generation with seed
    - Configurable council context
    - Volume controls
    - JSON schema validation
    - Complete resident records (name + address + service requests)
    """

    def __init__(
        self,
        seed: Optional[int] = None,
        council_name: str = "Sample Council",
        region: str = "Sample Region"
    ):
        """
        Initialize comprehensive data generator.

        Args:
            seed: Random seed for deterministic generation
            council_name: Name of council for context
            region: Geographic region for context
        """
        self.seed = seed
        self.council_name = council_name
        self.region = region

        # Initialize sub-generators with same seed
        self.name_generator = UKNameGenerator(seed)
        self.address_generator = UKAddressGenerator(seed)
        self.service_generator = CouncilServiceGenerator(seed)
        self.random = random.Random(seed)

    def generate_resident(self, resident_id: int) -> Dict[str, Any]:
        """
        Generate a complete resident record.

        Args:
            resident_id: Unique resident identifier

        Returns:
            Dict with name, address, and metadata
        """
        name = self.name_generator.generate_name()
        address = self.address_generator.generate_address()

        return {
            "residentId": f"{SAMPLE_DATA_PREFIX} RES-{resident_id:06d}",
            "name": name,
            "address": address,
            "councilName": self.council_name,
            "region": self.region,
            "createdAt": datetime.now().isoformat(),
            "sampleMarker": SAMPLE_DATA_MARKER
        }

    def generate(
        self,
        data_volume: int = 100,
        include_service_requests: bool = True
    ) -> Dict[str, Any]:
        """
        Generate complete dataset for a scenario.

        Args:
            data_volume: Number of resident records to generate
            include_service_requests: Whether to generate service requests

        Returns:
            Dict with complete dataset and metadata
        """
        start_time = datetime.now()

        # Generate residents
        residents = [
            self.generate_resident(i) for i in range(data_volume)
        ]

        # Generate service requests if requested
        service_requests = []
        if include_service_requests:
            service_requests = self.service_generator.generate_requests(
                count=data_volume
            )

        end_time = datetime.now()
        generation_time = (end_time - start_time).total_seconds()

        return {
            "metadata": {
                "councilName": self.council_name,
                "region": self.region,
                "generatedAt": end_time.isoformat(),
                "generationTime": generation_time,
                "seed": self.seed,
                "dataVolume": data_volume,
                "sampleMarker": SAMPLE_DATA_MARKER,
                "version": "1.0.0"
            },
            "residents": residents,
            "serviceRequests": service_requests,
            "recordCounts": {
                "residents": len(residents),
                "serviceRequests": len(service_requests),
                "total": len(residents) + len(service_requests)
            }
        }

    def validate_data(self, data: Dict[str, Any]) -> bool:
        """
        Validate generated data structure.

        Args:
            data: Generated dataset

        Returns:
            True if valid, raises ValueError otherwise
        """
        required_keys = ["metadata", "residents", "serviceRequests", "recordCounts"]

        for key in required_keys:
            if key not in data:
                raise ValueError(f"Missing required key: {key}")

        # Validate sample markers
        if data["metadata"].get("sampleMarker") != SAMPLE_DATA_MARKER:
            raise ValueError("Missing sample marker in metadata")

        # Validate record counts
        if len(data["residents"]) != data["recordCounts"]["residents"]:
            raise ValueError("Resident count mismatch")

        if len(data["serviceRequests"]) != data["recordCounts"]["serviceRequests"]:
            raise ValueError("Service request count mismatch")

        return True
